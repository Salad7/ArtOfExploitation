#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <string.h>
/*
Client - Acts as the de-facto source for sending to the host
*/


// Dumps raw memory in hex byte and printable split format
void dump(const unsigned char * data_buffer,
    const unsigned int length) {
    unsigned char byte;
    unsigned int i, j;
    for (i = 0; i < length; i++) {
      byte = data_buffer[i];
      printf("%02x ", data_buffer[i]); // Display byte in hex. if(((i%16)==15) || (i==length-1)) {
      for (j = 0; j < 15 - (i % 16); j++) printf(" ");
      printf("| ");
      for (j = (i - (i % 16)); j <= i; j++) { // Display printable bytes from line.
        byte = data_buffer[j];
        if ((byte > 31) && (byte < 127)) // Outside printable char range
          printf("%c", byte);
        else
          printf(".");
      }
      printf("\n"); // End of the dump line (each line is 16 bytes) } // End if
    } // End for }
}


#define PORT 7890
//Creating an Enum for booleans because my version C doesn't support boolean
enum booleans {TRUE, FALSE};



//Method that will return TRUE if socket is created, false otherwise
enum booleans createSocket(int* __socket){
	*__socket = socket(AF_INET,SOCK_STREAM,0);
	if(*socket < 0){
		return FALSE;
	}
	return TRUE;
};

enum booleans connectSocket(int* __socket, struct sockaddr_in socketAddress){
//Create the sockaddr_in wrapper to send data
	socketAddress.sin_family = AF_INET;
	socketAddress.sin_port = htons(PORT);
	socketAddress.sin_addr.s_addr = 0;
	int con = connect(*__socket,(struct sockaddr*)&socketAddress,sizeof(socketAddress));
	if(con < 0){
		printf(" error connecting to socket");
		return FALSE;
	}
	return TRUE;
}

enum booleans bindSocket(int* __socket, struct sockaddr_in* socketAddress){
	//Create the sockaddr_in wrapper to send data
	socketAddress->sin_family = AF_INET;
	socketAddress->sin_port = htons(PORT);
	socketAddress->sin_addr.s_addr = 0;
	int bindIn = bind(*__socket, (struct sockaddr*)socketAddress,sizeof(struct sockaddr));
	memset(&(socketAddress->sin_zero),'\0',8);
	if(bindIn < 0){
				printf(" error binding to socket result: %d",bindIn);

		return FALSE;
	}

	return TRUE;
}

enum booleans listenSocket(int* __socket){
int listenIn = listen(*__socket,1);
if(listenIn < 0){
	return FALSE;
}
return TRUE;
}

void acceptSocket(int* __socket, struct sockaddr_in* socketAddressHost){
	//createSocket(*__socket);
	socklen_t nAddrLen;;
	nAddrLen = sizeof(struct sockaddr_in);
	int bytesRec;
	char buffer[1024];
	while(1){
	int acceptIn = accept(*__socket,(struct sockaddr*)socketAddressHost,&nAddrLen);
		if(acceptIn == -1){
			printf("Error\n");
			break;
		}
		printf("got a connection");
		int sendIn = send(acceptIn,"suck it up",10,0);
		if (sendIn < 0)
		{
			printf("error sending");
		}
		bytesRec = recv(acceptIn,&buffer,1024,0);
		while(bytesRec > 0){
			printf("Recived %d bytes", bytesRec);
			dump(&buffer,bytesRec);
			bytesRec = recv(acceptIn,&buffer,1024,0);

		}
		close(acceptIn);	//return 0;
		}	
		//return 0;
}


int main(){

int socket, socketHost;
int yes = 1;
struct sockaddr_in socketAddress, socketAddressHost;

//Checking if socket is valid
if(createSocket(&socket) == TRUE){
	if(setsockopt(socket,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int)) == -1){
		printf("setsockopt fails");
	}
		//Check to see if socket has binded to local address
		if(bindSocket(&socket,&socketAddress) == TRUE){
			if(listenSocket(&socket) == TRUE){
				//printf("success");
				acceptSocket(&socket,&socketAddressHost);

			}
		}

}


}


